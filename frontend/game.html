<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Lap Tracker 3D Demo</title>
    <style>
      html, body { margin: 0; height: 100%; overflow: hidden; background: #0b0f16; }
      #hud {
        position: fixed; left: 12px; top: 12px;
        color: #e7eefc; font: 13px/1.35 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        background: rgba(0,0,0,0.35); padding: 10px 12px; border-radius: 10px;
        backdrop-filter: blur(6px);
        white-space: pre;
      }
      #err {
        position: fixed; right: 12px; top: 12px;
        color: #ffd1d1; font: 12px/1.35 system-ui, sans-serif;
        background: rgba(120,0,0,0.35); padding: 10px 12px; border-radius: 10px;
        backdrop-filter: blur(6px);
        max-width: 46ch;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="hud">Connecting</div>
    <div id="err"></div>

    <!-- Three.js via ESM CDN -->
    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

      // ---- CONFIG ----
      const API_BASE = "http://localhost:8000";
      const POLL_MS = 100;              // poll interval
      const HALL_MIN_X = -3.5;          // hallway left boundary in world units
      const HALL_MAX_X =  3.5;          // hallway right boundary
      const SMOOTHING = 0.15;           // 0..1 (higher = snappier)

      const hud = document.getElementById("hud");
      const errBox = document.getElementById("err");

      function showError(msg) {
        errBox.style.display = "block";
        errBox.textContent = msg;
      }
      function clearError() {
        errBox.style.display = "none";
        errBox.textContent = "";
      }

      // ---- THREE SETUP ----
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 2.2, 7.5);
      camera.lookAt(0, 0.6, 0);

      // lights
      scene.add(new THREE.AmbientLight(0xffffff, 0.55));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(5, 8, 3);
      scene.add(dir);

      // floor grid
      const grid = new THREE.GridHelper(12, 24, 0x2a3a5a, 0x1b2a44);
      grid.position.y = -0.01;
      scene.add(grid);

      // hallway rails (visual bounds)
      const railMat = new THREE.MeshStandardMaterial({ color: 0x334a73, roughness: 0.6, metalness: 0.1 });
      const railGeo = new THREE.BoxGeometry(0.06, 0.2, 10);
      const leftRail = new THREE.Mesh(railGeo, railMat);
      const rightRail = new THREE.Mesh(railGeo, railMat);
      leftRail.position.set(HALL_MIN_X, 0.1, 0);
      rightRail.position.set(HALL_MAX_X, 0.1, 0);
      scene.add(leftRail, rightRail);

      // cube (the "person")
      const cube = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.6, 0.6),
        new THREE.MeshStandardMaterial({ color: 0x7dd3fc, roughness: 0.35, metalness: 0.15 })
      );
      cube.position.set(0, 0.3, 0);
      scene.add(cube);

      // target position from API, smoothed in render loop
      let targetX = 0;
      let lastApi = { hallway_progress: null, lap_count: null, lap_state: null, current_lap_progress: null };

      // ---- API POLLING ----
      async function fetchJSON(path) {
        const res = await fetch(`${API_BASE}${path}`, { cache: "no-store" });
        if (!res.ok) throw new Error(`${path} -> HTTP ${res.status}`);
        return await res.json();
      }

      async function poll() {
        try {
          // parallel fetch all endpoints
          const [h, c, s, p, sc, ec] = await Promise.all([
            fetchJSON("/hallway_progress"),
            fetchJSON("/lap_count"),
            fetchJSON("/lap_state"),
            fetchJSON("/current_lap_progress"),
            fetchJSON("/start_is_calibrated"),
            fetchJSON("/end_is_calibrated"),
          ]);

          clearError();

          lastApi = {
            hallway_progress: h.hallway_progress,
            lap_count: c.lap_count,
            lap_state: s.lap_state,
            current_lap_progress: p.current_lap_progress,
            start_is_calibrated: sc.start_is_calibrated,
            end_is_calibrated: ec.end_is_calibrated,
          };

          // map hallway_progress [0..1] -> world X [HALL_MIN_X..HALL_MAX_X]
          const hp = Number(lastApi.hallway_progress);
          const clamped = Number.isFinite(hp) ? Math.min(1, Math.max(0, hp)) : 0;
          targetX = HALL_MIN_X + clamped * (HALL_MAX_X - HALL_MIN_X);

          hud.textContent =
            `hallway_progress: ${clamped.toFixed(3)}\n` +
            `current_lap_progress: ${Number(lastApi.current_lap_progress).toFixed(3)}\n` +
            `lap_state: ${String(lastApi.lap_state)}\n` +
            `lap_count: ${String(lastApi.lap_count)}\n` +
            `start_is_calibrated: ${String(lastApi.start_is_calibrated)}\n` +
            `end_is_calibrated: ${String(lastApi.end_is_calibrated)}`;

        } catch (e) {
          hud.textContent = `Could not reach API at ${API_BASE}\n` +
            `Make sure FastAPI is running and CORS/network allow it.\n\n` +
            `Error: ${e.message || e}`;
        } finally {
          setTimeout(poll, POLL_MS);
        }
      }
      poll();

      // ---- ANIMATION LOOP ----
      function animate() {
        requestAnimationFrame(animate);

        // smooth cube x toward targetX
        cube.position.x += (targetX - cube.position.x) * SMOOTHING;

        // small visual flair: tilt based on velocity
        const vx = (targetX - cube.position.x);
        cube.rotation.z = THREE.MathUtils.clamp(-vx * 0.25, -0.35, 0.35);
        cube.rotation.y += 0.01;

        renderer.render(scene, camera);
      }
      animate();

      // ---- RESIZE ----
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
